#!/bin/sh
ROOT_DIR=$(realpath $(dirname "$0")/..)
cd "$ROOT_DIR" || exit 1


function _fetch_link()
{
    local link_path="${1:-}"
    local repo_name="${2:-}"
    local ref="${3:-}"

    if [ -z "$link_path" ] || [ -z "$repo_name" ] || [ -z "$ref" ]; then
        echo "ERROR: Invalid link. It should contain values for the following params separated by spaces:" \
            "<link path in project> <repo name> <ref>" >&2
        echo "But got: <$link_path> <$repo_name> <$ref>" >&2
        return 1
    fi
    (
        set -eu

        local git_base_url=$(git config --get remote.origin.url | sed -E "s~([^/:]+)/([^/]+)[.]git$~~g" )
        local target_repo_url="${git_base_url}${repo_name}.git"

        case "$link_path" in
            *.link) ;;
            *) link_path="$link_path.link" ;;
        esac

        echo "LINK_PATH  = $link_path"
        echo "REPO_URL   = $target_repo_url"
        echo "REF        = $ref"
        echo

        if [ -L "$link_path" ]; then
            rm "$link_path"
        elif [ -e "$link_path" ]; then
            echo "ERROR: Path $link_path already exists and is not a symlink. Skipping." >&2
            return 1
        fi

        mkdir -p "$link_path"
        cd "$link_path"
        git init -q
        git remote add origin "$target_repo_url"
        git fetch --depth 1 origin "$ref"
        git checkout "$ref"
    )
}


function fetch_links()
{
    local links_file="$ROOT_DIR/.links"
    if [ ! -f "$links_file" ]; then
        echo "Links file not found: $links_file"
        return 1
    fi

    local line link_path repo_name ref_name

    while IFS= read -r line; do
    case "$line" in
        ''|\#*) ;;         # Skip empty lines and lines starting with #
        *)
            line=$(echo "$line" | sed 's/\s*#.*$//')
            set -- $line
            _fetch_link "$@"
        ;;
    esac
    done < .links
}



fetch_links "$@"
